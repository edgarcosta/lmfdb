R<x> := PolynomialRing(Rationals()); K<a> := NumberField(x^2 + 1);
DefiningPolynomial(K);
Degree(K);
magma>Rank(E);
1 true
magma>AnalyticRank(E);magma>AnalyticRank(E);
1 0.30600
magma>Regulator(E);magma>Regulator(E);
0.0511114082399688402358860997569
magma>(Discriminant(E) gt 0 select 2 else 1) * RealPeriod(E);magma>(Discriminant(E) gt 0 select 2 else 1) * RealPeriod(E);
5.98691729246391925966401995891
magma>TamagawaNumbers(E);magma>TamagawaNumbers(E);
[ 1 ]
magma>Order(TorsionSubgroup(E));magma>Order(TorsionSubgroup(E));
1
magma>MordellWeilShaInformation(E);magma>MordellWeilShaInformation(E);
[ 1, 1 ]
[ (0 : 0 : 1) ]
[
    <2, [ 0, 0 ]>
]
magma>Lr1 where r,Lr1 := AnalyticRank(E: Precision:=12);magma>Lr1 where r,Lr1 := AnalyticRank(E: Precision:=12);
0.305999773834
magma>/* self-contained Magma code snippet for the BSD formula (checks rank, < gma>mula (checks rank, c                                                  omputes analytic sha) */magma>/* self-contained Magma code snippet for the BSD formula (checks rank, c\
omputes analytic sha) */
magma>E := EllipticCurve([0, 0, 1, -1, 0]); r := Rank(E); ar,Lr1 := AnalyticR< gma>ar,Lr1 := AnalyticRa                                                   nk(E: Precision := 12); assert r eq ar;magma>E := EllipticCurve([0, 0, 1, -1, 0]); r := Rank(E); ar,Lr1 := AnalyticRa\
nk(E: Precision := 12); assert r eq ar;
magma>sha := MordellWeilShaInformation(E); omega := RealPeriod(E) * (DiscriSignature(K);
OK := Integers(K); Discriminant(OK);
PrimeDivisors(Discriminant(OK));
Automorphisms(K);
IntegralBasis(K);
ClassGroup(K);
UK, fUK := UnitGroup(K);
UnitRank(K);
K!f(TU.1) where TU,f is TorsionUnitGroup(K);
[K|fUK(g): g in Generators(UK)];
Regulator(K);
/* self-contained Magma code snippet to compute the analytic class number formula */
Qx<x> := PolynomialRing(Rationals()); K<a> := NumberField(x^2 + 1);
OK := Integers(K); DK := Discriminant(OK);
UK, fUK := UnitGroup(OK); clK, fclK := ClassGroup(OK);
r1,r2 := Signature(K); RK := Regulator(K); RR := Parent(RK);
hK := #clK; wK := #TorsionSubgroup(UK);
2^r1 * (2*Pi(RR))^r2 * RK * hK / (wK * Sqrt(RR!Abs(DK)));
L := Subfields(K); L[2..#L];
G = GaloisGroup(K);
mi< gma>riod(E) * (Discrimin                                                   ant(E) gt 0 select 2 else 1);magma>sha := MordellWeilShaInformation(E); omega := RealPeriod(E) * (Discrimin\
ant(E) gt 0 select 2 else 1);

Using model [ 0, 0, 1, -1, 0 ]
Torsion Subgroup is trivial
Analytic rank = 1
     ==> Rank(E) = 1
The 2-Selmer group has rank 1
New point of infinite order (x = 1/4)
After 2-descent: 
    1 <= Rank(E) <= 1
    Sha(E)[2] is trivial
(Searched up to height 100 on the 2-coverings.)

magma>reg := Regulator(E); tam := &*TamagawaNumbers(E); tor := #TorsionSubgro< gma>r := #TorsionSubgrou                                                   p(E);magma>reg := Regulator(E); tam := &*TamagawaNumbers(E); tor := #TorsionSubgrou\
p(E);
magma>assert r eq ar; print "analytic sha:", Lr1 * tor^2 / (omega * reg * tam< gma> (omega * reg * tam)                                                   ;magma>assert r eq ar; print "analytic sha:", Lr1 * tor^2 / (omega * reg * tam)\
;
analytic sha: 1.00000000000
magma>ModularForm(E);magma>ModularForm(E);
q - 2*q^2 - 3*q^3 + 2*q^4 - 2*q^5 + 6*q^6 - q^7 + 6*q^9 + 4*q^10 - 5*q^11 + 
O(q^12)
magma>ModularDegree(E);magma>ModularDegree(E);
2
magma>ManinConstant(E);magma>ManinConstant(E);
1
magma>[LocalInformation(E,p) : p in BadPrimes(E)];magma>[LocalInformation(E,p) : p in BadPrimes(E)];
[ <37, 1, 1, 1, I1, falp := 7; [<pr[2], Valuation(Norm(pr[1]), p)> : pr in Factorization(p*Integers(K))];
